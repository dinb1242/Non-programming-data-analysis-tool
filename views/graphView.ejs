<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plotly.js Test</title>

    <link rel="stylesheet" href="/css/index.css">
    <%- include ("./common/cssScript") %>
        <!-- Jquery -->


        <!-- Plotly.js -->
        <script src="https://cdn.plot.ly/plotly-1.58.4.min.js"></script>

        <!-- Danfo.js -->
        <script src="https://cdn.jsdelivr.net/npm/danfojs@0.2.4/lib/bundle.min.js"></script>

        <!-- Tensorflow.js -->
        <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@2.0.0/dist/tf.min.js"></script>

</head>

<body>
    <div class="MainContainer">
        <div class="topBack">
            <div class="ui container expPage">
                <div class="textBox">
                    <p><span style="font-size: 26px; line-height: 36px;">안녕하세요 여러분,<br><span class="yt">데이터 분석</span>
                            실험실에 오신걸
                            환영합니다.</span><br><br>
                        지금 부터 아래의 테이터를 이용하여, 데이터를 분석하고 조작한 그래프를 확인 할 수 있습니다.
                    </p>
                </div>
            </div>
        </div>
        <!-- DataFrame's table will be shown -->
        <div class="Container_layout">
            <div class="DanfoContainer">
                <h1 class="">데이터 조작 공간</h1>

                <!-- DataFrame Controls -->
                <form class="ui fluid form">


                    <div id="sb_x_col" style="display: inline-block; text-align: left;">
                        X Column<select id="select_x_col" onchange="onDataFrameChange(this, 0);">
                            <option value="none">컬럼을 선택하세요.</option>
                            <!-- Option tag will be shown by processing Javascript function -->
                        </select>
                    </div>

                    <div id="sb_y_col" style="display: inline-block; text-align: left;">
                        <span id="span_y_col_text">Y Column : </span>
                        <select id="select_y_col" onchange="onDataFrameChange(this, 1);">
                            <option value="none">컬럼을 선택하세요.</option>
                            <!-- Option tag will be shown by processing Javascript function -->
                        </select>
                    </div>

                    <!-- Combo box second y column (will be used for line plot) -->
                    <div id="sb_y2_col" style="display: inline-block; text-align: left;">
                        <span id="span_y2_col_text">Y Column (for Line Plot) : </span>
                        <select id="select_y2_col" onchange="onDataFrameChange(this, 2);">
                            <option value="none">컬럼을 선택하세요.</option>
                            <!-- Option tag will be shown by processing Javascript function -->
                        </select>
                    </div>

                    <button type="button" class="ui icon button green" onclick="makeDataFrame();"><i
                            class="check circle white icon"></i></button>
                    <button type="button" class="ui icon button red" onclick="resetDataFrame();"><i
                            class="trash alternate outline white icon"></i></button>
                    <input type="checkbox" id="cb_is_grouped" onchange="onGroupedCheckBoxChange(this);" />
                    <label id="lb_is_grouped" for="cb_is_grouped">X축 기준 집계 (Aggregate)</label>
                    <select id="select_aggregate_method" onchange="onAggregateCheckBoxChange(this);">
                        <option value="mean">평균</option>
                        <option value="max">최대값</option>
                    </select>
                </form>
                <div id="danfo_dataframe"></div>
            </div>

            <!-- Plotly's Graph will be shown -->
            <div class="PlotlyContainer">
                <h1>Plotly.js Test</h1>

                <!-- Graph Controls -->
                <form class="ui fluid form">
                    <select onchange="onGraphChange(this);" id="sb_graph_select">
                        <option value="lines" selected>선 그래프</option>
                        <option value="markers">산점도 그래프</option>
                        <option value="box">박스 그래프</option>
                        <option value="bar">막대 그래프</option>
                        <option value="combo">콤보 그래프</option>
                    </select>
                    <div class="PlotlyGraph" id="plotly_graph"></div>
                    <div class="trend_line">
                        <button type="button" class="ui button" onclick="makeSLGraphWithTrendline();">추세선 그리기</button>
                        <button type="button" class="ui button" onclick="makeScatterAndLineGraph();">추세선 초기화</button>
                    </div>
                    <div id="trendline_value">
                        <p id="trendline_x"></p>
                        <p id="trendline_y"></p>
                        <p id="trendline_equation"></p>
                        <p id="r_squared"></p>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script>
        ////////////////////////////////////////////////////////
        // Variables    
        ////////////////////////////////////////////////////////
        let dataset_path = "";

        let graphType;

        let df; // DataFrame will be contained
        let count = 0;

        let dfXCol;
        let dfYCol;
        let dfY2Col;
        let dfXColData;
        let dfYColData;
        let dfY2ColData;

        let aggregateMethod = "";

        let isGrouped = 0;

        ////////////////////////////////////////////////////////
        // Page Initialize
        ////////////////////////////////////////////////////////
        $(document).ready(function () {
            // Initialize the graph
            $("#sb_graph_select").find("option").eq(0).prop("selected", true);
            $("#select_aggregate_method").find("option").eq(0).prop("selected", true);
            $("input:checkbox[id='cb_is_grouped']").prop("checked", false);
            $("#cb_is_grouped, #lb_is_grouped").hide();
            $("#select_aggregate_method").hide();
            hideDfY2Col();
            graphType = "lines";
            aggregateMethod = "mean";
            makeScatterAndLineGraph(graphType);

            //Initialize the DataFrame
            // Danfo script and will be shown on html
            if ("<%=dataset_id%>" == "0") {
                dataset_path = "https://raw.githubusercontent.com/dinb1242/datasets/master/weather-in-jeju.csv";
            } else {
                dataset_path = "https://raw.githubusercontent.com/dinb1242/datasets/master/weather-issue-data.csv";
            }
            try {
                dfd.read_csv(dataset_path)
                    .then((result) => {
                        initializeDf(result);
                    })
            } catch (err) {
                console.log(`데이터셋을 불러오는 중 오류가 발생했습니다.\n${err}`);
            }
        })

        function initializeDf(result) {
            // Dataframe init and print on html
            df = result;
            df.plot("danfo_dataframe").table({ layout: { height: 800 } });

            // Create select tag's options using columns of DataFrame
            let selectXCol = document.getElementById("select_x_col");
            let selectYCol = document.getElementById("select_y_col");
            let selectY2Col = document.getElementById("select_y2_col");
            let selectOption;

            dfCols = df.columns;
            dfCols.forEach((element, idx) => {
                selectOption = document.createElement("option");
                selectOption.setAttribute("value", element);
                selectOption.innerHTML = element;
                selectXCol.appendChild(selectOption);

                selectOption = document.createElement("option");
                selectOption.setAttribute("value", element);
                selectOption.innerHTML = element;
                selectYCol.appendChild(selectOption);

                selectOption = document.createElement("option");
                selectOption.setAttribute("value", element);
                selectOption.innerHTML = element;
                selectY2Col.appendChild(selectOption);
            });
        }

        ////////////////////////////////////////////////////////
        // Logic function
        ////////////////////////////////////////////////////////

        // 2-dim array to 1-dim array
        function reshapeTo1d(arr) {
            let twoDimArr = []
            arr.forEach(element => {
                twoDimArr.push(element[0])
            })

            return twoDimArr;
        }

        // Number Range Function
        function range(start, end) {
            let arr = [];
            let length = end - start;

            for (var i = 0; i <= length; i++) {
                arr[i] = start;
                start++;
            }

            return arr;
        }

        function calcMaxAgainstX(uniqueXData, yCol){
            let tempArr = []
            uniqueXData.forEach(label => {
                tempArr.push( Math.max.apply(null, df.query({ column: dfXCol, is: "==", to: label })[yCol].values) )
            })

            return tempArr;
        }

        function calcMeanAgainstX(uniqueXData, yCol){
            let tempArr = []
            uniqueXData.forEach(label => {
                tempArr.push( df.query({ column: dfXCol, is: "==", to: label })[yCol].mean());
            })

            return tempArr;
        }

        function calcRSquared(yTrue, yPred) {
            // yTure = dfYColData
            // yPred = trendY
            let tensorYTrue = tf.tensor1d(yTrue);
            let tensorYPred = tf.tensor1d(yPred);

            let sst = tensorYTrue.sub(tensorYTrue.mean()).square().sum()
            let sse = tensorYPred.sub(tensorYTrue.mean()).square().sum()
            let ssr = tensorYTrue.sub(tensorYPred).square().sum()

            let r2 = 1 - Array.from(ssr.div(sst).dataSync())[0]

            return r2;
        }

        // calcLSM Calculus for Trendline
        // it returns tensor array
        function calcLSM(xArr, yArr) {
            let tensorX = tf.tensor1d(xArr);
            let tensorY = tf.tensor1d(yArr);

            // Get Average
            let xMean = tensorX.mean();
            let yMean = tensorY.mean();

            // Get Coefficient and Intercept
            let divisor = tensorX.sub(xMean).mul(tensorY.sub(yMean)).sum()
            let dividend = tensorX.sub(xMean).square().sum();

            let coef = divisor.div(dividend);
            let intercept = yMean.sub(xMean.mul(coef));

            return [coef, intercept];
        }

        function rSquared() {
            let sse;
            let ssr;
            let sst;
        }

        // Set new Graph
        function makeScatterAndLineGraph() {
            let trace1 = {
                x: dfXColData,
                y: dfYColData,
                mode: graphType
            }

            let layout = {
                title: "Test Title",
                xaxis: {
                    title: dfXCol
                },
                yaxis: {
                    title: dfYCol
                },
                height: 400
            }

            let config = {
                responsive: true,
            }

            let data = [trace1];

            Plotly.newPlot("plotly_graph", data, layout, config);
        }

        // Scatter or Line Graph with Tendline()
        function makeSLGraphWithTrendline() {
            // Equation, tensor type
            let trendEquation = calcLSM(dfXColData, dfYColData);
            console.log(trendEquation[0].print(), trendEquation[1].print());

            let minX = Array.from(tf.tensor1d(dfXColData).min().dataSync())[0];
            let maxX = Array.from(tf.tensor1d(dfXColData).max().dataSync())[0];

            // X = dfXColData
            let trendY = Array.from(trendEquation[0].mul(dfXColData).add(trendEquation[1]).dataSync());

            let rSquared = Math.ceil(calcRSquared(dfYColData, trendY) * 10000) / 10000;

            // Get rounded numbers for quation
            let equationX = Math.ceil(Array.from(trendEquation[0].dataSync())[0] * 100) / 100;
            let equationY = Math.ceil(Array.from(trendEquation[1].dataSync())[0] * 100) / 100;

            // Show trendline's x and y value on html
            let pTagtrendX = document.getElementById("trendline_x");
            let pTagtrendY = document.getElementById("trendline_y");
            let pTagtrendEquation = document.getElementById("trendline_equation");
            let pTagRSquared = document.getElementById("r_squared");
            pTagtrendX.innerHTML = `x : ${equationX}`;
            pTagtrendY.innerHTML = `y : ${equationY}`;
            pTagtrendEquation.innerHTML = `Equation : ${equationX} * x + ${equationY}`;
            pTagRSquared.innerHTML = `R-Squared : ${rSquared} (about ${rSquared * 100}%)`

            let trace1 = {
                x: dfXColData,
                y: dfYColData,
                mode: graphType
            }

            let trendLine = {
                x: dfXColData,
                y: trendY,
                mode: "lines"
            }

            let layout = {
                title: "Test Title",
                xaxis: {
                    title: dfXCol
                },
                yaxis: {
                    title: dfYCol
                },
                height: 400
            }

            let data = [trace1, trendLine];

            Plotly.newPlot("plotly_graph", data, layout)
        }

        function makeBoxGraph() {
            // A box graph that can remove a point which is clicked.
            let trace0 = {
                y: dfYColData,
                type: "box"
            }

            let layout = {
                hovermode: "closest",
                title: "Click Event Test",
                yaxis: {
                    title: dfYCol
                },
                height: 400
            }

            let data = [trace0]

            Plotly.newPlot("plotly_graph", data, layout);

            // Create a click and elete data-point event on box plot
            var boxGraphElement = document.getElementById("plotly_graph");

            boxGraphElement.on("plotly_click", (data) => {
                onBoxGraphDataDelete(data);
            })
        }

        function makeBarGraph() {
            let trace0 = {
                x: dfXColData,
                y: dfYColData,
                type: "bar"
            }
            if (isGrouped) {
                /*
                    The the check box is checked, the flow is:
                        1. Extract unique data in X (It will be label data) -> uniqueXData Variable
                        2. Extract Max number in Y data using each unique data of X -> maxYData Array
                */
                let uniqueXData = df[dfXCol].unique().values;
                let yDataForBar;
                if(aggregateMethod == "mean"){
                    yDataForBar = calcMeanAgainstX(uniqueXData, dfYCol);
                } else if(aggregateMethod == "max"){
                    yDataForBar = calcMaxAgainstX(uniqueXData, dfYCol);
                }
                
                trace0.x = uniqueXData;
                trace0.y = maxYData;

                console.log(trace0.x, trace0.y);
            }
            let data = [trace0];

            let layout = {
                xaxis: {
                    title: dfXCol
                },
                yaxis: {
                    title: dfYCol
                },
                height: 400
            }
            Plotly.newPlot("plotly_graph", data, layout);
        }

        // Developing...
        function makeComboGraph() {
            // Implement 
            let traceForBar = {
                x: dfXColData,
                y: dfYColData,
                type: "bar"
            }

            let traceForLine = {
                x: dfXColData,
                y: dfY2ColData,
                type: "line"
            }

            if (isGrouped) {
                /*
                    The the check box is checked, the flow is:
                        1. Extract unique data in X (It will be label data) -> uniqueXData Variable
                        2. Extract Max number in Y data using each unique data of X -> maxYData Array
                */
                let uniqueXData = df[dfXCol].unique().values;
                let yDataForBar = null;
                let yDataForLine = null;

                if(aggregateMethod == "mean"){
                    yDataForBar = calcMeanAgainstX(uniqueXData, dfYCol);
                    yDataForLine = calcMeanAgainstX(uniqueXData, dfY2Col);
                } else if(aggregateMethod == "max"){
                    yDataForBar = calcMaxAgainstX(uniqueXData, dfYCol);
                    yDataForLine = calcMaxAgainstX(uniqueXData, dfY2Col);
                }

                traceForBar.x = uniqueXData;
                traceForBar.y = yDataForBar;

                traceForLine.x = uniqueXData;
                traceForLine.y = yDataForLine;

                console.log(traceForBar.x, traceForBar.y);
                console.log(traceForLine.x, traceForLine.y);
            }
            let data = [traceForBar, traceForLine];

            let layout = {
                xaxis: {
                    title: dfXCol
                },
                yaxis: {
                    title: dfYCol
                },
                height: 400
            }
            Plotly.newPlot("plotly_graph", data, layout);
        }

        // Set new DataFrame
        async function makeDataFrame() {

            let isSelectBoxXColVisible = $("#sb_x_col").is(":visible");

            // When X col and Y col are activated.
            if (isSelectBoxXColVisible) {
                if (graphType == "combo") {
                    if (!dfXCol || !dfYCol || !dfY2Col || dfXCol == "none" || dfYCol == "none" || dfY2Col == "none") {
                        alert("모든 컬럼을 선택하세요.")
                        return false;
                    } else {
                        df.loc({ columns: [dfXCol, dfYCol, dfY2Col] }).plot("danfo_dataframe").table(); // Reload DataFrame
                        dfXColData = reshapeTo1d(df.loc({ columns: [dfXCol] }).values)
                        dfYColData = reshapeTo1d(df.loc({ columns: [dfYCol] }).values)
                        dfY2ColData = reshapeTo1d(df.loc({ columns: [dfY2Col] }).values)
                    }
                } else {
                    if (!dfXCol || !dfYCol || dfXCol == "none" || dfYCol == "none") {
                        alert("모든 컬럼을 선택하세요.")
                        return false;
                    } else {
                        df.loc({ columns: [dfXCol, dfYCol] }).plot("danfo_dataframe").table(); // Reload DataFrame
                        // Set Dataframe's data
                        dfXColData = reshapeTo1d(df.loc({ columns: [dfXCol] }).values)
                        dfYColData = reshapeTo1d(df.loc({ columns: [dfYCol] }).values)
                    }
                }
                // Re-draw a graph according to the graph type
                if (graphType == "lines" || graphType == "markers") {
                    await makeScatterAndLineGraph();
                }
                else if (graphType == "bar") {
                    await makeBarGraph();
                } else if (graphType == "combo") {
                    await makeComboGraph();
                }
            } else { // When Only one Columns
                if (!dfYCol || dfYCol == "none") {
                    alert("컬럼을 선택하세요.")
                } else {
                    dfYColData = reshapeTo1d(df.loc({ columns: [dfYCol] }).values)
                    df.loc({ columns: [dfYCol] }).plot("danfo_dataframe").table();
                    await makeBoxGraph()
                }
            }
        }

        // Reset Graph
        function resetGraph() {
            Plotly.newPlot("plotly_graph", [{
                x: null,
                y: null,
                mode: graphType
            }]);
        }

        // Reset DataFrame
        function resetDataFrame() {
            df.plot("danfo_dataframe").table();
            resetGraph(); // Grpah will be reset too.
        }

        // Hide X Col
        function hideDfXCol() {
            dfXCol = null; // As X Columns select box will be deleted, the data must be deleted.
            dfXColData = null;
            $("#select_x_col").find("option").eq(0).prop("selected", true); // When X column select box appeared, the default value must be initialized.
            $("#sb_x_col").hide();
        }

        function hideDfY2Col() {
            dfY2Col = null;
            dfY2ColData = null;
            $("#select_y2_col").find("option").eq(0).prop("selected", true);
            $("#sb_y2_col").hide();
        }

        function hideChIsGrouped() {
            isGrouped = 0; // Initialize before being hidden
            $("#cb_is_grouped, #lb_is_grouped").hide();
        }

        ////////////////////////////////////////////////////////
        // Handler functions
        ////////////////////////////////////////////////////////

        // when selected bar graph, is Checkbox checked or not
        function onGroupedCheckBoxChange(e) {
            isGrouped = $("#cb_is_grouped").is(":checked");
            if (isGrouped) {
                $("#select_aggregate_method").show();
            } else {
                $("#select_aggregate_method").hide();
            }
            try {
                makeBarGraph();
            } catch (err) {
                console.log("Columns are not defined.");
            }
        }

        function onAggregateCheckBoxChange(e) {
            aggregateMethod = e.value;
        }

        // If a point on box graph is clicked
        async function onBoxGraphDataDelete(data) {
            let pts = '';
            let dataTrueIdx;

            // When click only data-point
            if (data.points.length == 1) {
                // pts = "x : " + data.points[0].x + "\ny : " + data.points[0].y;
                pts = "y : " + data.points[0].y;
                if (confirm("삭제 하시겠습니까?\n\n삭제될 데이터 :\n" + pts)) {
                    // Delete data-point
                    dataTrueIdx = reshapeTo1d(df.loc({ columns: [dfYCol] }).eq(data.points[0].y).data).indexOf(true)
                    df.drop({ index: [dataTrueIdx], axis: 0, inplace: true }); // Data Drop
                    df.reset_index({ inplace: true });

                    // Reload DataFrame and box plot
                    await makeDataFrame();
                } else {
                    return;
                }
            } else {
                console.log("데이터의 집합입니다.");
            }
        }

        // When select box of graph is changed
        let spanY2ColText = document.getElementById("span_y_col_text");

        function onGraphChange(e) {
            graphType = e.value;


            if (graphType == "lines" || graphType == "markers") {
                $(".trend_line").fadeIn();

            } else {
                $(".trend_line").hide()
            }



            if (graphType == "lines" || graphType == "markers") {
                resetGraph();
                spanY2ColText.innerText = "Y Column";
                $("#sb_x_col").show();
                hideChIsGrouped();
                hideDfY2Col();
                makeScatterAndLineGraph();
            } else if (graphType == "box") {
                resetGraph();
                spanY2ColText.innerText = "Y Column";
                // If graphType is not "lines" or "markers"
                // X column and its data must be deleted.
                hideDfXCol();
                hideDfY2Col();
                hideChIsGrouped();

            } else if (graphType == "bar") {
                resetGraph();
                spanY2ColText.innerText = "Y Column";
                hideDfY2Col();
                $("#sb_x_col").show();
                $("#cb_is_grouped, #lb_is_grouped").show();
                makeBarGraph();
            } else if (graphType == "combo") {
                resetGraph();
                spanY2ColText.innerText = "Y Column (for Bar Plot)"
                $("#sb_y2_col").show();
                $("#sb_x_col").show();
                $("#cb_is_grouped, #lb_is_grouped").show();
            }

        }

        function onDataFrameChange(e, selectBoxIdx) {
            // 0: first select box
            // 1: second select box
            if (selectBoxIdx == 0) {
                dfXCol = e.value;
            } else if (selectBoxIdx == 1) {
                dfYCol = e.value;
            } else if (selectBoxIdx == 2) {
                dfY2Col = e.value;
            }
            console.log(dfXCol, dfYCol, dfY2Col);
        }

            ////////////////////////////////////////////////////////
            // Table Event Handler
            ////////////////////////////////////////////////////////
    </script>
</body>

</html>